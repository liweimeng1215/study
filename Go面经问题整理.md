Golang后端开发面经问题整理

```
Q：消息队列怎么保证不重复消费
A：首先，重复消费在消息队列系统的生产者、MQ以及消费者中都有可能出现，其中分别对应，1. 生产者可能连续调用了两次生产接口；2. MQ由于崩溃没有接收到消费者消费结束的ACK指令重复发送消息；3. 消费者已经消费后准备向MQ发送ACK指令时崩溃，导致MQ又发送了消息。 
避免重复消费的情况最好解决方案是在消费者处做幂等性处理，例如将消费后消息缓存到redis中，新消息消费前确认是否重复，或者在数据库层添加唯一性约束（消息和数据库记录对应的情况下）
https://cloud.tencent.com/developer/article/1444056
https://xie.infoq.cn/article/72f1f64f7bca1b55d9934666b

Q：mysql的事务有哪些隔离级别，可重复读是怎么实现的，生成快照的具体过程
A：隔离级别有：
	假设有两个并行事务A、B
	1. 读未提交。读未提交没有对事务操作进行加锁，因此会导致事务A读取操作会读到事务B更新操作（还未提交）后的结果。
	2. 读已提交。在事务B提交前，事务A读取的数据都是一致的。实现：通过多版本并发控制（MVCC）实现，在每次读取数据时生成快照，记录数据状态。
	3. 可重复读。在事务B提交后，事务A读取的数据依旧是一致的。实现：仅在事务开始时生成快照，此外mysql中的可重复读也可以解决幻读问题（事务A在不同时刻查询数据期间，事务B插入了一条数据），通过对事务A的查询条件添加间隙锁阻塞事务B的执行，从而解决幻读问题。
	4. 可串行化。将读写事务作为顺序执行。实现：读事务中添加共享锁，其它事务仅被允许读；在写事务中添加排它锁，其它事务被阻塞。
	生成快照的具体过程：
	Mysql数据库中每行数据不仅包含当前展示的字段，还包含了隐藏ID、版本链索引以及事务ID，版本链索引指向的记录为undo log（记录了数据的历史状态），快照生成则会记录快照读时的undo log的版本状态。
	快照是mysql实现MVCC的一个工具，MVCC则是mysql实现高并发读写的方式，适用于读已提交和可重复读。MVCC实现原理：
	事务进行快照读时，会维护相关的快照以及读视图（read view），其中快照记录当前数据版本，读视图则维护当前活跃事务ID列表以及当前事务的可见性判断，读已提交在每次快照读时都会获取最新的快照以及读视图，从而可以读取其它事务已提交的数据，可重复度只在第一次快照读时生成快照以及读视图，后续快照读时都是使用之前的快照以及读视图。
https://zhuanlan.zhihu.com/p/117476959?utm_source=wechat_session&utm_medium=social&utm_oi=665942151582715904
https://juejin.cn/post/6871046354018238472
https://www.modb.pro/db/223394

Q：项目里缓存怎么保证一致性？
A：这个问题应该是说怎么保证缓存和数据库的一致性。
先说下背景吧，在数据库高并发查询场景下，对于一些数据库热点数据，需要对其进行缓存，避免高并发请求直接访问数据库导致数据库瘫痪。
当我们对数据进行修改时，通常是先更新数据库，然后再删除缓存，后续读请求未命中缓存则重新在数据库中读取数据并添加缓存。为达成数据一致性目标，我们需要确保用户读取的不是旧的数据，所以我们要确保缓存被删除。可以通过添加消息中间件（例如rabbitMQ）实现：更新数据库后将删除缓存的消息放入消息中间件中，如果失败则会重试，确保消息最终能够被消费。
Q：为什么是删除缓存而不是更新缓存？
A：因为通常缓存的数据是数据库联表进行了一系列复杂操作后的数据，对其进行更新代价更大。在多线程情况下，可能会导致旧缓存数据覆盖新缓存数据的结果。
Q：为什么是先更新数据库再删除缓存？先后顺序可以调换吗？
A：如果调换操作顺序，先删除缓存，再更新数据库，这可能会导致A线程正在执行写入操作，已经将缓存删除，但更新数据库操作受到了阻塞，此时B线程查询数据库后又设置了缓存，导致缓存和数据库不一致。
https://www.51cto.com/article/705167.html

Q：redis的分布式锁怎么实现的，有哪些缺点？
A：首先讲下分布式锁的背景，在分布式系统中，不同客户端可能运行在不同的主机上，所以当这些客户端去访问某些共享资源时会出现竞争的现象，需要添加分布式锁设置对其访问顺序。
redis实现分布式锁主要在于如何实现加锁和解锁。
setnx命令确保在加锁时只能有一个客户端进行操作，该客户端添加锁后，其余客户端必须等待该客户端解锁后才能重新加锁。
解锁操作只需在redis中删除加锁时设置的键值对，但必须确保只有加锁客户端才能解锁，可以通过Lua脚本编写解锁逻辑并增加对解锁用户的身份校验从而保证操作原子性。
缺点：1. 可能存在业务操作超时而锁已经到期的情况；2. redis服务器时钟漂移导致锁过早到期，多个客户端可能持有同一把锁的情况；3. 从redis master节点获取锁后，master崩溃，锁还未来得及同步到slave节点，可能会导致多个客户端持有同一把锁的情况。
2、3可以通过使用RedLock算法在一定程度上避免（还是存在不安全的可能），算法原理主要是设置多个redis master实例，通过向大多数master申请锁保证锁的高可用性
1 java中可通过redission中间件维持一个对加锁客户端进行监视的进程，如果客户端存活会定期更新锁的存活时间，确保进程正常情况下执行完成后再释放锁。
https://segmentfault.com/a/1190000038988087

Q：go的gmp模型，调度过程
A：GMP模型中的G、M、P分别对应goroutine、内核态线程以及goroutine队列，其目的就是将可运行的goroutine调度到工作线程上执行。
GMP中还有几个非常重要的组件：
1. P节点。根据GO配置在程序执行前生成对应数量的P节点。
2. P本地队列。P本地队列中存放待执行的G。
3. 全局队列。本地队列已满的情况下将G放入到全局队列等待执行。
4. 内核态线程M。M寻找可用的P，与之结合后从中获取待执行的G结合并执行。如果P队列为空可从全局队列或者其它P队列中偷取G。
Q：从其他队列窃取多少过来，系统调用完成后m会休眠吗，goroutine发生死循环p会怎么调度
A：首先从全局队列窃取，窃取数量符合公式：n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))，若是从其它P本地队列窃取，窃取其数量的一半。当没有可执行的G后，与P绑定的M会进入自旋状态，等待G的产生后立即执行。若M未与P进行绑定，则会进入休眠状态，等待其它M让出P。
goroutine发生死循环其实就是G执行出现阻塞的情况。首先说明一下，调度器支持协作和抢占两种调度策略。协作策略是在用户态通过调用runtime接口主动放弃调度，对用户对GO语言使用要求更高，存在用户态代码没有主动释放执行权的情况下，G会一直被阻塞的缺陷。抢占策略通过系统监控判断发生阻塞的G后注入中断信号，解绑P与M，让出资源给其它G执行。所以，当goroutine发生死循环后，会被监控线程检测到阻塞，然后执行抢占策略让出调度资源。
https://blog.csdn.net/slphahaha/article/details/121173762
https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/
https://learnku.com/articles/41728

Q：go的内存逃逸是什么，函数里的声明一个对象指针会发生逃逸吗
A：内存逃逸是指原本在栈上的变量（例如，局部变量）由于生命周期的延长必须要转移到堆上，应用GC对其进行管理。
如果对象指针作为返回值则会发生逃逸。
Q：内存逃逸有什么缺点？如何避免？
A：虽然内存逃逸可以避免复制，但GC管理对程序性能的影响可能会更大。尽量少用指针。
https://zhuanlan.zhihu.com/p/441593663

Q：进程和线程的区别
A：进程是操作系统资源分配的最小单元，在创建或者销毁进程时给其分配或回收对应的系统资源例如内存以及IO等，进程间切换速度慢，代价高。而线程可以理解为一个进程内的不同执行路径，可共享进程的系统资源，线程间切换代价小，速度快，是CPU进行调度的基本单位。实际上，进程和线程都是为CPU并发服务的，CPU执行时间可分为多个时间片，在执行一个程序时快速地对各个线程进行切换，从而达到同时执行多个事件的效果，例如音乐播放器在播放音乐的同时也可以放映字幕。
https://cloud.tencent.com/developer/article/1688297
https://www.zhihu.com/question/25532384
https://www.jianshu.com/p/d89d650e4114

Q：mysql索引的底层实现原理、mysql 的索引优化
A：mysql索引就像是数据的目录，使用户能够快速整理数据以及搜索数据。Mysql默认存储引擎为innodb，其底层实现是B+树，在非叶子节点存储索引值，在叶子节点存储对应数据，其中聚簇索引存储的就是数据库中对应的数据记录，非聚簇索引存储主键值。
Mysql索引优化的目的实际上也是数据库查询优化，解决这类的问题的一般方法是：
1. 首先开启mysql慢查询日志，等待业务跑了一段时间后查看耗时较长的sql语句。
2. 通过show profile查看对应sql执行各个时期的时间消耗，如若是sending data阶段耗费了大量时间则有可能是执行计划没有走索引。
3. 确认是否走索引可以用explain命令查看sql的执行计划，通过建立合适索引以及优化查询条件（例如将负向）改善查询速度。
Q：如何建立合适索引？
A：	
	1. 选择唯一性的列作为索引。该字段作为查询条件时，需扫描的行数会更少。
	2. 为经常需要排序、分组以及联合操作的列建立索引。索引可有效降低排序的时间消耗。
	3. 常作为查询条件的字段建立索引。
	4. 不要滥用索引。虽然索引可以提升查询速度，但建立索引需要额外的磁盘空间，并在每次数据更新后同步更新并排序，过多索引表会降低数据库更新操作的性能。
	5. 索引数据长度尽量短，对于长字符串格式可使用前缀索引。数据长度更短有利于索引表的维护。
	6. 删除未使用的索引。
https://www.cnblogs.com/frankdeng/p/8990181.html
https://mp.weixin.qq.com/s/Me1whVwbFPAlYuHIkytYpQ
https://www.51cto.com/article/625199.html
https://juejin.cn/post/6867180058549682184

Q：redis基本数据类型有哪些？底层实现是怎样的？
A：redis的五大基本数据类型为：string, list, hash, set以及zset。底层均由redisObject进行封装，其中根据成员变量type确定数据类型，encoding确定编码方式（根据数据量类型以及大小确定不同的编码方式可有效提高资源利用率），ptr则指向实际的数据块。
https://zhuanlan.zhihu.com/p/344918922
https://www.cnblogs.com/ysocean/p/9102811.html

Q：浏览器打开一个网站的具体流程有哪些？
A：在浏览器中输入网址后，浏览器进程首先会在本地host缓存中查找是否有对应网址的地址映射，如果没有，会请求dns服务获取网址对应服务器ip，获取到ip后申请与服务器进行TCP连接（三次握手），握手成功后发送http请求，服务器接收到请求后回复浏览器html页面，浏览器接收到html响应后对页面进行渲染得到可视化窗口。
https://www.zhihu.com/question/20513729
https://zhuanlan.zhihu.com/p/33149162

Q：TCP和UDP的区别是什么？TCP可靠性体现在哪里？拥塞控制的手段有哪些？四次挥手的流程和状态变化？
A：主要区别在于TCP面向可靠的连接进行数据传输，传输具有可靠性；UDP面向无连接进行数据传输，传输不具备可靠性。
Q：面向连接是什么意思？
面向连接指TCP在数据通信之前会经历3次握手，确保通信双方均具备发送以及接收数据的能力，在结束通信时会进行4次挥手，确保信息传输的完整性。
3次握手具体过程：
	1. 第一次握手，客户端向服务端发送 SYN 报文，并进入 SYN_SENT 状态
	2. 第二次握手，服务端接收到客户端发送的 SYN 报文后，返回客户端 ACK 报文，并添加自己的 SYN 报文，进入 SYN_RCVD 状态
	3. 第三次握手，客户端接收到服务端的 ACK+SYN 报文后，返回服务端 ACK 报文，服务端接收到 ACK 报文后双方连接建立完成
Q：为什么是3次握手而不是2次？
	1. 双方均需要确认具备接收以及发送的能力。2次握手无法确保通信双方确认其具备发送以及接收的能力。当完成第二次握手时，客户端接收到服务端的报文后，可确认其具备发送以及接收的能力，服务器也具备发送以及接收能力，但服务器方无法确认其ACK报文是否被正常接收。因此，需要第三次握手使服务方确认其发送能力。
	2. 序列号可靠同步。第二次握手时会将服务端的初始序列号发送到客户端，如果该报文丢失，客户端不知道服务端的初始序列号，无法进行可靠传输。
	3. 阻止重复历史连接的初始化。若两次握手后服务器即可进行连接，那么有可能由于客户端发送了两次SYN信号，服务端由于网络延迟接收到了旧的SYN信息从而开启了连接，这就导致了连接的混乱。
	4. 安全问题。两次握手增大了DDOS攻击的风险。
Q：4次挥手是什么？
A：4次挥手具体过程：
	1. 第一次挥手。客户端向服务端发送 FIN 包，并添加包序号 u，进入 FIN_WAIT_1 状态。
	2. 第二次挥手。服务器接收到 FIN 包后，回复 ACK 包（ack=u+1），客户端接收到ACK包后进入 FIN_WAIT_2 状态，此时客户端已无数据发送，服务端可能还存在部分数据未发送，服务器进入到 CLOSE_WAIT 状态，并进行数据传输。
	3. 第三次挥手。当服务器也没有数据要进行传输时，发送 FIN 包，添加序列号 w，发送给客户端，服务端进入到 LAST_ACK 状态
	4. 第四次挥手。客户端接收到服务端的 FIN 包后，发送 ACK 包（ack=w+1），进入TIME_WAIT状态，等待 2MSL 后关闭连接；服务端接收到客户端的 ACK 包后关闭连接。
Q：为什么 TIME_WAIT 状态需要经过 2MSL 才能返回 CLOSE 状态？
A：首先，MSL是网络报文最大存活时间，当客户端 ACK 报文没有到达服务端的情况下，服务端会重新发送 FIN 包，所以客户端需要等待2MSL确保能够收到服务端的 FIN 包。
其次，等待 2MSL 没有接收到网络包，说明在当前网络中已无网络包存活，可避免影响下一个新的连接中出现旧的网络包情况。
Q：TCP通过哪些方法保证可靠性？
A：
    1. 校验和。根据TCP伪首部、报头以及数据进行校验，判断数据有效性，如果校验不通过则丢弃。
    2. 序列号确认应答/超时重传。接收端发送ACK包（根据已收到数据添加对应序列号）确认收到数据，发送端超时未接收到对应ACK包则会进行重发。
    3. 最大消息长度。双方约定一个最大长度作为发送单位。
    4. 滑动窗口。提高发送端效率，不必等到接收到ACK包后再发送数据，窗口大小为无需等待ACK能发送的最大数据量。
    5. 拥塞控制。避免在网络拥塞的情况下加重网络负担。
        1）慢启动。拥塞窗口大小从1开始，首先根据网络状况进行倍数增长。
        2）拥塞避免。达到拥塞窗口的门限值后，窗口大小进行线性增长，出现网络状况后，调整门限值为当前窗口值大小的一半，并重新设置窗口大小为1，重新慢启动。
        3）快重传+快恢复。当连续收到三个同样的ACK请求时，说明存在丢包，应立即重传丢失数据包，并将拥塞窗口降低为当前指的一半，避免发送大量错误的包。
    https://www.eet-china.com/mp/a44399.html
    https://zhuanlan.zhihu.com/p/112317245
    https://zhuanlan.zhihu.com/p/37379780
```



